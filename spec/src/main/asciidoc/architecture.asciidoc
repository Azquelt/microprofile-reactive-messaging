//
// Copyright (c) 2018-2019 Contributors to the Eclipse Foundation
//
// See the NOTICE file(s) distributed with this work for additional
// information regarding copyright ownership.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

[[reactivemessagingarchitecture]]
== Architecture

The Reactive Messaging specification defines a development model for declaring CDI _beans_ producing, consuming and processing messages. 
The communication between these components uses Reactive Streams. 

This specification relies on https://github.com/eclipse/microprofile-reactive-streams-operators[Eclipse MicroProfile Reactive Streams Operators] and http://cdi-spec.org/[CDI].

=== Concepts

This section describes the different concepts introduced by the Reactive Messaging specification

==== Overall architecture

An application using Reactive Messaging is composed of CDI beans consuming, producing and processing _messages_.

These messages can be wholly _internal_ to the application or can be sent and received via different message brokers.

image::overall.png[Overall architecture]

Application's beans contain methods annotated with `@Incoming` and `@Outgoing` annotations. 
A method with an `@Incoming` annotation consumes messages from a _channel_. 
A method with an `@Outgoing` annotation publishes messages to a _channel_.
A method with both an `@Incoming` and an `@Outgoing` annotation is a message processor, it consumes messages from a _channel_, does some transformation to them, and publishes messages to another_channel_.

==== Channel

A _channel_ is a name indicating which source or destination of messages is used.
Channels are opaque `Strings`.

There are two types of channel:

* Internal channels are local to the application. 
They allows implementing multi-step processing where several _beans_ from the same application form a chain of processing.
* Channels can be _connected_ to remote brokers or various message transport layers such as Apache Kafka or to an AMQP broker.
These channels are managed by _connectors_.

==== Message

At the core of the Reactive Messaging specification is the concept of _message_. 
A _message_  is an enveloppe wrapping a _payload_. 
A message is sent to a specific channel and, when received and processed successfuly, _acknowledged_.

Reactive Messaging application components are addressable recipients which await the arrival of messages on a channel and react to them, otherwise lying dormant. 

Messages are represented by the `org.eclipse.microprofile.reactive.messaging.Message` class. 
This interface is intentionally kept minimal. The aim is that _connectors_ will provide their own implementations with additional metadata that is relevant to that connector.
For instance, a `KafkaMessage` would provide access to the _topic_ and _partition_.

The `org.eclipse.microprofile.reactive.messaging.Message#getPayload` method retrieves the wrapped payload. 
The `org.eclipse.microprofile.reactive.messaging.Message#ack` method acknowledges the message.
Note that the `ack` method is asynchronous as acknowledgement is generally an asynchronous process.

_Plain_ messages are created using:

* `org.eclipse.microprofile.reactive.messaging.Message#of(T)` - wraps the given payload, no acknowledgement
* `org.eclipse.microprofile.reactive.messaging.Message#of(T, java.util.function.Supplier<java.util.concurrent.CompletionStage<java.lang.Void>>)` - wraps the given payload and provides the acknowlegment logic

==== Message consumption with @Incoming

The `org.eclipse.microprofile.reactive.messaging.Incoming` annotation is used on a method from a CDI bean to indicate that the method consumes messages from the specified channel:

[source,java]
----
@Incoming("my-channel")                                                // <1>
public CompletionStage<Void> consume(Message<String> message) {        // <2>
  return message.ack();
}
----
1. `my-channel` is the channel
2. the method is called for every message sent to the `my-channel` channel

Reactive Messaging supports various forms of method signatures.
This is detailed in the next section.

Remember that Reactive Messaging interactions are assembled from Reactive Streams.
A method annotated with `@Incoming` is a Reactive Streams _subscriber_ and so consumes messages that fit with the message signature and its annotations.
Note that the handling of the Reactive Streams protocol, such as subscriptions and back pressure, is managed by the Reactive Messaging implementation.

From the user perspective, whether the incoming messages come from co-located beans or a remote message broker is transparent.
However, the user may decide to consume a specific subclass of `Message` if the user is aware of this characteristic:

[source,java]
----
@Incoming("my-kafka-topic")               
public CompletionStage<Void> consume(KafkaMessage<String> message) {    // <1>
  return message.ack();
}
----
1. Explicit consumption of a `KafkaMessage`

==== Message production with @Outgoing

The `org.eclipse.microprofile.reactive.messaging.Outgoing` annotation is used to annotate a method from a CDI bean to indicate that the method publishes messages to a specified channel:

[source,java]
----
@Outgoing("my-channel")                                        // <1>
public Message<String> publish() {                             // <2>
  return Message.of("hello");                                  // <3>
}
----
1. `my-channel` is the targeted channel
2. the method is called for every consumer _request_
3. you can create a _plain_ `org.eclipse.microprofile.reactive.messaging.Message` using `org.eclipse.microprofile.reactive.messaging.Message#of(T)`

Reactive Messaging supports various forms of method signatures.
This is detailed in the next section.

A method annotated with `@Outgoing` is a Reactive Streams _publisher_ and so publishes messages according to the requests it receives.

===== Method consuming and producing

A method can combine the `@Incoming` and `@Outgoing` annotation and will then act as a Reactive Streams processor:

[source,java]
----
@Incoming("my-incoming-channel")                            // <1>
@Outgoing("my-outgoing-channel")                            // <2>
public Message<String> process(Message<String> message) { 
  return Message.of(message.getPayload().toUpperCase());
}
----
1. The incoming channel
2. The outgoing channel

==== Connectors and Messaging Providers

The application can receive and forward messages from various message brokers or transport layers.
For instance, an application can be connected to a Kafka cluster, an AMQP broker or an MQTT server.

Reactive Messaging _Connectors_ are extensions managing the communication with a specific transport technology.
They are responsible for mapping a specific _channel_ to remote sink or source of messages.
This mapping is configured in the application configuration.
Note that an implementation may provide various ways to configure the mapping, but support for MicroProfile Config as a configuration source is mandatory.

Connectors are associated with a `org.eclipse.microprofile.reactive.messaging.MessagingProvider` class corresponding to a messaging transport, such as Apache Kafka, Amazon Kinesis, RabbitMQ or Apache ActiveMQ.
For instance, an hypthetic Kafka connector would be associated with the following class:

[source, java]
----
public class Kafka extends MessagingProvider {
  private Kafka() { }
}
----

Note that the class is just a marker class, it provides no actual functionality. 
The user can associate a channel with this connector using:

[source, properties]
----
mp.messaging.incoming.my-kafka-topic.type=...Kafka  # <1>
----
1. the value is the fully qualified name of the `MessagingProvider` class associated with the connector.

The configuration format is detailed later in this document.

The Reactive Messaging implementation is responsible for finding the connector implementation associated with the given `MessagingProvider` in the user configuration.
If the connector cannot be found, the deployment of the application must be failed.

The Reactive Messaging specification provides a SPI to implement connectors.

=== Design

==== Message stream operation

Message stream operation occurs according to the principles of reactive programming.
The back pressure mechanism of reactive streams means that a publisher will not send data to a subscriber unless there are outstanding subscriber requests.
This implies that data flow along the stream is enabled by the first request for data received by the publisher.
For methods that are annotated with `@Incoming` and `@Outgoing` this data flow control is handled automatically by the underlying system which will call the `@Incoming` and `@Outgoing` methods as appropriate.

Although `@Incoming` and `@Outgoing` methods remain callable from Java code, calling them directly will not affect the reactive streams they are associated with.
For example, calling an `@Outgoing` annotated method from user code will not post a message on a message queue and calling an `@Incoming` method cannot be used to read a message.
Enabling this would bypass the automatic back pressure mechanism that is one of the benefits of the specification.
The `@Incoming` and `@Outgoing` method annotations are used to declaratively define the stream which is then run by the implementation of MicroProfile Reactive Messaging without the user's code needing to handle concerns such as subscriptions or flow control within the stream.

==== Supported CDI scopes

Implementations of the Reactive Messaging specification must support at least the following CDI scopes:

* `@ApplicationScoped` beans
* `@Dependent` beans

The following code gives an example of a bean annotated with `@ApplicationScoped`:

[source,java]
----
@ApplicationScoped
public class ApplicationScopeBeans {

  @Outgoing("source")
  public Publisher<Integer> source() {
    return ReactiveStreams.of(id).buildRs();
  }

  @Incoming("source")
  @Outgoing("output")
  public int process(int i) {
    return i + 1;
  }

  @Incoming("output")
  public void sink(int v) {
    System.out.println(v);
  }
}
----

Implementations can provide support for other scopes. 
However the behavior is not defined.

==== Supported method signatures

The signature of message stream methods can have a number of different distinct types, offering differing levels of power and simplicity to application developers. Different shapes are supported depending on whether the method is a publisher, subscriber or processor, for example, a publishing stream supports returning MicroProfile Reactive Streams `PublisherBuilder`, but not `SubscriberBuilder`, the inverse is true for a subscribing stream.

This section lists the methods signatures that must be supported by the Reactive Messaging implementation.
Implementations must validate that the stream shape matches the `@Outgoing` and `@Incoming` annotations, if they don't, a CDI definition exception should be raised to the CDI container during initialization.

It's important to remember that users must not call these methods directly. 
They are invoked by the Reactive Messaging implementation following the Reactive Streams protocol.

Also the method must be implemented in a non-blocking fashion.
For blocking transformations, asynchronous variants can be used.

INFO: _assembly_ time is when the Reactive Messaging implementation initializes itself and creates the different bean instances and connects them together.

INFO: In the following lists, `Message` can be an implementation of the `Message` interface.

===== Methods producing data

[cols="2a,1,1",options="header"]
|===
|Signature
|Behavior
|Invocation

|
[source, java]
----
@Outgoing("name") 
Publisher<Message<O>> method()
----
| Returns a stream of `Message` associated with the channel `name`. 
| Method called once at assembly time.

|
[source, java]
----
@Outgoing("channel") 
Publisher<O> method()
----
| Returns a stream of _payload_ of type `O` associated with the channel `channel`. Produced payloads are mapped to `Message<O>` by the Reactive Messaging implementation.
| Method called once at assembly time.

|
[source, java]
----
@Outgoing("channel") 
PublisherBuilder<Message<O>> method()
----
| Returns a stream of `Message` associated with the channel `channel`. 
| Method called once at assembly time.

|
[source, java]
----
@Outgoing("channel") 
PublisherBuilder<O> method()
----
| Returns a stream of _payload_ associated with the channel `channel`. Produced payloads are mapped to `Message<O>` by the Reactive Messaging implementation.
| Method called once at subscription time.

|
[source, java]
----
@Outgoing("channel") 
Message<O> method()
----
| Produces an infinite stream of `Message` associated with the channel `channel`. 
|	This method is called for each _request_ made by the subscriber.

|
[source, java]
----
@Outgoing("channel")
O method()
----
| Produces an infinite stream of _payload_ associated with the channel `channel`. Produced payloads are mapped to `Message<O>` by the Reactive Messaging implementation.
|	This method is called for each _request_ made by the subscriber.

|
[source, java]
----
@Outgoing("channel")
CompletionStage<Message<O>> method()
----
| Produces an infinite stream of `Message` associated with the channel `channel`. The result is a `CompletionStage`. The method should not be called by the reactive messaging implementation until the `CompletionStage` returned previously is completed.
|	This method is called for each _request_ made by the subscriber.

|
[source, java]
----
@Outgoing("channel") 
CompletionStage<O> method()
----
| Produces an infinite stream of _payload_ associated with the channel `channel`. Produced payloads are mapped to `Message<O>` by the Reactive Messaging implementation. The result is a `CompletionStage`. The method should not be called by the reactive messaging implementation until the `CompletionStage` returned previously is completed.
|	This method is called for each _request_ made by the subscriber.

|===


===== Methods consuming data

[cols="2a,1,1",options="header"]
|===
|Signature
|Behavior
|Invocation

|
[source,java]
----
@Incoming("channel")
Subscriber<Message<I>> method()
----
| Returns a `Subscriber` that receives the `Message` objects transiting on the channel `channel`.
| The method is called only once to retrieve the `Subscriber` object at assembly time.
 This subscriber is connected to the matching channel.

|
[source,java]
----
@Incoming("channel")
Subscriber<I> method()
----
| Returns a `Subscriber` that receives the _payload_ objects transiting on the channel `channel`.
The payload is automatically extracted from the inflight messages using `Message.getPayload()`.
| The method is called only once to retrieve the `Subscriber` object at assembly time.
 This subscriber is connected to the matching channel.

|
[source,java]
----
@Incoming("channel") 
SubscriberBuilder<Message<I>> method()
----
| Returns a `SubscriberBuilder` that receives the `Message` objects transiting on the channel `channel`.
| The method is called only once at assembly time to retrieve a `SubscriberBuilder` that is used to build a `CompletionSubscriber` that is subscribed to the matching channel. 

|
[source,java]
----
@Incoming("channel")
SubscriberBuilder<I> method()
----
| Returns a `SubscriberBuilder` that is used to build a `CompletionSubscriber<I>`` that receives the _payload_ of each `Message`.
The payload is automatically extracted from the inflight messages using `Message.getPayload()`.
| The method is called only once at assembly time to retrieve a `SubscriberBuilder` that is used to build a `CompletionSubscriber` that is subscribed to the matching channel. 

|
[source,java]
----
@Incoming("channel")
void method(I payload)
----
| Consumes the _payload_.
The method can return `void` or any object or `null`. 
The returned value is ignored. 
| This method is called for every `Message<I>` instance transiting on the channel `channel`. 
The payload is automatically extracted from the inflight messages using `Message.getPayload()`.
The user method is never called concurrently and so must return before being called with the next payload.

|
[source,java]
----
@Incoming("channel")
CompletionStage<?> method(Message<I> msg)
----
| Consumes the `Message` 
| This method is called for every `Message<I>` instance transiting on the channel `channel`. 
The user method is never called concurrently. The reactive messaging implementation must wait until the completion of the previously returned `CompletionStage` before calling the method again with the next `Message`.
Note that `@Incoming("channel") void method(Message<I> msg)` is not allowed as message acknowledgement is asynchronous.

|
[source,java]
----
@Incoming("channel") 
CompletionStage<?> method(I payload)
----
| Consumes the _payload_ asynchronously
| This method is called for every `Message<I>` instance transiting on the channel `channel`. 
The payload is automatically extracted from the inflight messages using `Message.getPayload()`.
The user method is never called concurrently. The reactive messaging implementation must wait until the completion of the previously returned `CompletionStage` before calling the method again with the next _payload_.

|===
	
===== Methods processing data

[cols="2a,1,1",options="header"]
|===
|Signature
|Behavior
|Invocation

| 
[source,java]
----
@Incoming("in")
@Outgoing("out")
Processor<Message<I>, Message<O>> method()
----
| Returns a Reactive Streams processor consuming incoming `Message` instances and produces `Message` instances.
| This method is called once; at assembly time.

| 
[source,java]
----
@Incoming("in")
@Outgoing("out") 
Processor<I, O> method();
----
| Returns a Reactive Streams processor consuming incoming _payload_ instances and produces _payload_ instances.
| This method is called once; at assembly time.

|
[source,java]
----
@Incoming("in")
@Outgoing("out") 
ProcessorBuilder<Message<I>, Message<O>> method();
----
| Returns a `ProcessorBuilder` consuming incoming `Message` instances and produces `Message` instances.
| This method is called once; at assembly time.

|
[source,java]
----
@Incoming("in")
@Outgoing("out") 
ProcessorBuilder<I, O> method();
----
| Returns a Reactive Streams processor that consuming incoming _payload_ instances and produces _payload_ instances.
| This method is called once; at assembly time.

|
[source,java]
----
@Incoming("in")
@Outgoing("out") 
Publisher<Message<O>> method(Message<I> msg)
----
| Returns a Reactive Streams `Publisher` for each incoming `Message`.
The returned `Publisher` can be empty or emits multiple `Message` instances.
If the returned `Publisher` emits several elements, these elements are _flatten_ in the outgoing stream as a concatenation of elements.
The _flattening_ follows the same semantics as the `flatMap` operator from the MicroProfile Reactive Streams specification.
| This method is called for every incoming message. Implementations must not call the method subsequently until the stream from the previously returned `Publisher` is completed.

|
[source,java]
----
@Incoming("in")
@Outgoing("out") 
Publisher<O> method(I payload)
----
| Returns a Reactive Streams `Publisher` for each incoming _payload_.
The returned `Publisher` can be empty or emits multiple _payload_ instances.
If the returned `Publisher` emits several elements, these elements are _flatten_ in the outgoing stream as a concatenation of elements.
The _flattening_ follows the same semantics as the `flatMap` operator from the MicroProfile Reactive Streams specification.
The Reactive Messaging implementation must create new `Message` instances for each emitted _payload_ as well as extracing the payload for each incoming `Message`.
| This method is called for every incoming message. Implementations must not call the method subsequently until the stream from the previously returned `Publisher` is completed.

|
[source,java]
----
@Incoming("in")
@Outgoing("out") 
PublisherBuilder<Message<O>> method(Message<I> msg)
----
| Returns a `PublisherBuilder` for each incoming `Message`.
The stream resulting from the built `Publisher` can be empty or emits multiple `Message` instances.
If the stream emitted from the built `Publisher` emits several elements, these elements are _flatten_ in the outgoing stream as a concatenation of elements.
The _flattening_ follows the same semantics as the `flatMap` operator from the MicroProfile Reactive Streams specification.
| This method is called for every incoming message. Implementations must not call the method subsequently until the stream built from the previously returned `PublisherBuilder` is completed.

|
[source,java]
----
@Incoming("in")
@Outgoing("out") 
PublisherBuilder<O> method(I payload)
----
| Returns a `PublisherBuilder` for each incoming _payload_.
The stream resulting from the built `Publisher` can be can be empty or emits multiple _payload_ instances.
If the stream emitted from the built `Publisher` emits several elements, these elements are _flatten_ in the outgoing stream as a concatenation of elements.
The _flattening_ follows the same semantics as the `flatMap` operator from the MicroProfile Reactive Streams specification.
The Reactive Messaging implementation must create new `Message` instances for each emitted _payload_ as well as extracing the payload for each incoming `Message`.
| This method is called for every incoming message. Implementations must not call the method subsequently until the stream built from the previously returned `PublisherBuilder` is completed.


|
[source,java]
----
@Incoming("in")
@Outgoing("out") 
Message<O> method(Message<I> msg)
----
| Returns a `Message` for each incoming `Message`.
| This method is called for every incoming message. Implementations must not call the method subsequently until the previous call must have returned.

|
[source,java]
----
@Incoming("in")
@Outgoing("out") 
O method(I payload)
----
| Returns a _payload_ for each incoming _payload.
The Reactive Messaging implementation is responsible for unwrapping the _payload_ from the incoming `Message` and creating a `Message` from the returned _payload_.
| This method is called for every incoming message. Implementations must not call the method subsequently until the previous call must have returned.

|
[source,java]
----
@Incoming("in")
@Outgoing("out") 
CompletionStage<Message<O>> method(Message<I> msg)
----
| Produces a `Message` for each incoming `Message`. This method returns a `CompletionStage` that can redeem the `Message` instance asynchronously. The returned `CompletionStage` must not be completed with `null`.
| This method is called for every incoming message. Never concurrently. The implementations must wait until the completion of the previously returned `CompletionStage` before calling the method again with the next `Message`.
|
[source,java]
----
@Incoming("in")
@Outgoing("out") 
CompletionStage<O> method(I payload)
----
| Produces a _payload_ for each incoming _payload_. This method returns a `CompletionStage` that can redeem the _payload_ instance asynchronously. The returned `CompletionStage` must not be completed with `null`.
| This method is called for every incoming _payload_. Never concurrently. The implementations must wait until the completion of the previously returned `CompletionStage` before calling the method again with the next _payload_.

|
[source,java]
----
@Incoming("in")
@Outgoing("out") 
Publisher<Message<O>> method(Publisher<Message<I>> pub)
----
| Applies a transformation to the incoming stream of `Message`. This method is used to manipulate streams and apply stream transformations.
| This method is called once, at _assembly_ time.

|
[source,java]
----
@Incoming("in")
@Outgoing("out") 
PublisherBuilder<Message<O>> method(PublisherBuilder<Message<I>> pub)
----
| Applies a transformation to the stream represented by the `PublisherBuilder` of `Message`. This method is used to manipulate streams and apply stream transformations.
| This method is called once, at _assembly_ time.

|
[source,java]
----
@Incoming("in")
@Outgoing("out") 
Publisher<O> method(Publisher<I> pub)
----
| Applies a transformation to the incoming streams of _payloads_.  This method is used to manipulate streams and apply stream transformations.
| This method is called once, at _assembly_ time.

|
[source,java]
----
@Incoming("in")
@Outgoing("out") 
PublisherBuilder<O> method(PublisherBuilder<I> pub)
----
| Applies a transformation to the stream represented by the `PublisherBuilder` of _payloads_. This method is used to manipulate streams and apply stream transformations.
| This method is called once, at _assembly_ time.

|===

===== Examples of simple method streams

The simplest shape that an application may use is a simple method. This is a method that accepts an incoming message, and possibly publishes an outgoing message:

[source, java]
----
@Incoming("in")
@Outgoing("out")
public Message<O> process(Message<I> msg) {
  return convert(msg);
}
----

In the above example, the stream is both a publishing and subscribing stream, with a 1:1 mapping of incoming to outgoing messages. 
Asynchronous processing may also be used, by returning a `CompletionStage`:

[source, java]
----
@Incoming("in")
@Outgoing("out")
public CompletionStage<Message<O>> processMessage(Message<I> msg) {
  return asyncConvert(msg);
}
----

If the method is not `@Outgoing` annotated, then the returned value is ignored - however, note that for asynchronous methods, the returned `CompletionStage` is still important for determining when message processing has completed successfully, for the purposes of message acknowledgement. 
When there is no `@Outgoing` annotation, `void` may also be returned.

In addition to `Message`, implementations must allow:

* payloads (the content wrapped in a `Message`)
* implementation of the `Message` interface

===== Examples of methods using Reactive Streams or MicroProfile Reactive Streams Operators types

For more power, developers may use Reactive Streams instances. Reactive Streams shaped methods accept no parameters, and return one of the following:

* `org.eclipse.microprofile.reactive.streams.PublisherBuilder`
* `org.eclipse.microprofile.reactive.streams.SubscriberBuilder`
* `org.eclipse.microprofile.reactive.streams.ProcessorBuilder`
* `org.reactivestreams.Publisher`
* `org.reactivestreams.Subscriber`
* `org.reactivestreams.Processor`

Implementations may optionally support other types, such as JDK9 Flow publishers, subscribers and processors, or other representations of Reactive Streams. 
Application developers are recommended to use the MicroProfile Reactive Streams Operators _builders_ in order to allow for the highest level of portability.

For example, here's a message processor:

[source, java]
----
@Incoming
@Outgoing
public PublisherBuilder<IncomingMessage, OutgoingMessage> processMessages() {
  return ReactiveStreams.<IncomingMessage>builder()
    .map(this::convert);
}
----

==== Message acknowledgement

Acknowledgement is an important part of message processing.
Messages are either acknowledged explicitly, or implicitly by the implementation.

Acknowledgement for the `@Incoming` messages is controlled by the `org.eclipse.microprofile.reactive.messaging.Acknowledgment` annotation. 
The annotation allows configuring the acknowledgement strategy among:

* `NONE` - no acknowledgment is performed
* `MANUAL` - the user is responsible for the acknowledgement, by calling the `Message#ack()` method, so the Reactive Messaging implementation does not apply implicit acknowledgement
* `PRE_PROCESSING` - the Reactive Messaging implementation acknowledges the message before the annotated method or processing is executed
* `POST_PROCESSING` - the Reactive Messaging implementation acknowledges the message once:

  1. the method or processing completes if the method does not emit data
  2. when the emitted data is acknowledged

Each method signature type has different defaults and can implement different acknowledgement policies.
If the `Acknowledgment` annotation is not set, the default policy is applied.

IMPORTANT: Method only annotated with `@Outgoing` do not support acknowledgement as they don't receive an input `Message`.

The following table indicates the defaults and supported acknowledgement for each supported signature:

[cols="2a,1,1",options="header"]
|===
|Signature
|Default Acknoledgement Strategy
|Supported Strategies

|
[source,java]
----
@Incoming("channel")
Subscriber<Message<I>> method()
----
| Post-Processing	
| None, Pre-Processing, Post-Processing, Manual

|
[source,java]
----
@Incoming("channel")
Subscriber<I> method()
----
| Post-Processing	
| None, Pre-Processing, Post-Processing

|
[source,java]
----
@Incoming("channel") 
SubscriberBuilder<Message<I>> method()
----
| Post-Processing	
| None, Pre-Processing, Post-Processing, Manual


|
[source,java]
----
@Incoming("channel")
SubscriberBuilder<I> method()
----
| Post-Processing	
| None, Pre-Processing, Post-Processing

|
[source,java]
----
@Incoming("channel")
void method(I payload)
----
| Post-Processing	
| None, Pre-Processing, Post-Processing

|
[source,java]
----
@Incoming("channel")
CompletionStage<?> method(Message<I> msg)
----
| Post-Processing
| None, Pre-Processing, Post-Processing, Manual

|
[source,java]
----
@Incoming("channel") 
CompletionStage<?> method(I payload)
----
| Post-Processing	
| None, Pre-Processing, Post-Processing

| 
[source,java]
----
@Incoming("in")
@Outgoing("out")
Processor<Message<I>, Message<O>> method()
----
| Pre-Processing
| None, Pre-Processing, Manual
Post-Processing can be optionaly supported by implementations, however it requires a 1:1 mapping between the incoming element and the outgoing element.

| 
[source,java]
----
@Incoming("in")
@Outgoing("out") 
Processor<I, O> method();
----
| Pre-Processing
| None, Pre-Processing
Post-Processing can be optionaly supported by implementations, however it requires a 1:1 mapping between the incoming element and the outgoing element.

|
[source,java]
----
@Incoming("in")
@Outgoing("out") 
ProcessorBuilder<Message<I>, Message<O>> method();
----
| Pre-Processing
| None, Pre-Processing, Manual
Post-Processing can be optionaly supported by implementations, however it requires a 1:1 mapping between the incoming element and the outgoing element.

|
[source,java]
----
@Incoming("in")
@Outgoing("out") 
ProcessorBuilder<I, O> method();
----
| Pre-Processing
| None, Pre-Processing
Post-Processing can be optionaly supported by implementations, however it requires a 1:1 mapping the incoming element and the outgoing element.

|
[source,java]
----
@Incoming("in")
@Outgoing("out") 
Publisher<Message<O>> method(Message<I> msg)
----
| Pre-Processing
| None, Manual, Pre-Processing

|
[source,java]
----
@Incoming("in")
@Outgoing("out") 
Publisher<O> method(I payload)
----
| Pre-Processing
| None, Pre-Processing

|
[source,java]
----
@Incoming("in")
@Outgoing("out") 
PublisherBuilder<Message<O>> method(Message<I> msg)
----
| Pre-Processing
| None, Manual, Pre-Processing

|
[source,java]
----
@Incoming("in")
@Outgoing("out") 
PublisherBuilder<O> method(I payload)
----
| Pre-Processing
| None, Pre-Processing


|
[source,java]
----
@Incoming("in")
@Outgoing("out") 
Message<O> method(Message<I> msg)
----
| Post-Processing
| None, Manual, Pre-Processing, Post-Processing

|
[source,java]
----
@Incoming("in")
@Outgoing("out") 
O method(I payload)
----
| Post-Processing
| None, Pre-Processing, Post-Processing

|
[source,java]
----
@Incoming("in")
@Outgoing("out") 
CompletionStage<Message<O>> 
method(Message<I> msg)
----
| Post-Processing
| None, Manual, Pre-Processing, Post-Processing

|
[source,java]
----
@Incoming("in")
@Outgoing("out") 
CompletionStage<O> method(I payload)
----
| Post-Processing
| None, Pre-Processing, Post-Processing

|
[source,java]
----
@Incoming("in")
@Outgoing("out") 
Publisher<Message<O>> method(Publisher<Message<I>> pub)
----
| Pre-Processing
| None, Manual, Pre-Processing

|
[source,java]
----
@Incoming("in")
@Outgoing("out") 
PublisherBuilder<Message<O>> method(PublisherBuilder<Message<I>> pub)
----
| Pre-Processing
| None, Manual, Pre-Processing

|
[source,java]
----
@Incoming("in")
@Outgoing("out") 
Publisher<O> method(Publisher<I> pub)
----
| Pre-Processing
| None, Pre-Processing

|
[source,java]
----
@Incoming("in")
@Outgoing("out") 
PublisherBuilder<O> method(PublisherBuilder<I> pub)
----
| Pre-Processing
| None, Pre-Processing

|===

Invalid acknowledgement policies must be detected and a `DeploymentException` raised when the application is deployed.

===== Acknowledgement Examples

Transiting data may be wrapped in a `Message`, which can be used to supply metadata, and also allows messages to be acknowledged. 
The contract for acknowledging messages is anything that accepts a `Message` is required to acknowledge it. 
So, if the application receives an incoming message wrapped in `Message`, it is responsible for invoking `Message.ack()`, and if the application publish an outgoing message wrapped in `Message`, then the spec implementation is responsible for invoking `Message.ack()`.

For example, the following application code is incorrect, since it accepts a message wrapped in `Message`, but does not acknowledge the messages:

[source, java]
----
@Incoming
@Acknowledgment(MANUAL)
public void processMessage(Message<IncomingMessage> msg) {
  System.out.println("Got message " + msg.getPayload());
}
----

Here is a correct implementation:

[source, java]
----
@Incoming
@Acknowledgment(MANUAL)
public CompletionStage<Void> processMessage(Message<IncomingMessage> msg) {
  System.out.println("Got message " + msg.getPayload());
  return msg.ack();
}
----

This implementation is also correct, since the application is returning a wrapped message back to the implementation, making it the implementations responsibility to invoke `ack()`:

[source, java]
----
@Incoming
public Message<?> processMessage(Message<IncomingMessage> msg) {
  System.out.println("Got message " + msg.getPayload());
  return msg;
}
----

The above is particularly useful for processing messages that are also being sent to a destination, as the implementation must not invoke `ack` until after the outgoing message has been sent to the destination:

[source, java]
----
@Incoming
@Outgoing
public Message<OutgoingMessage> processMessage(Message<IncomingMessage> msg) {
  return Message.of(convert(msg.getPayload()), msg::ack);
}
----

The implementation is reponsible for enforcing the acknowledgement strategy defined by the user when the `@Acknowledgement` policy is used. 
If the annotation is not used, the default policy must be enforced.

// ==== Custom message types

// Implementations may provide custom subtypes of `Message` as an end user API, for the purpose of providing additional metadata associated with the messaging provider. If an application declares that it consumes or produces a subtype of the `Message` wrapper, the implementation should validate that the messaging provider supports that message wrapper type, and raise a deployment exception if it doesn't.
