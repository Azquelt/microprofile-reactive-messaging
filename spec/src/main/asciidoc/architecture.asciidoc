//
// Copyright (c) 2018-2019 Contributors to the Eclipse Foundation
//
// See the NOTICE file(s) distributed with this work for additional
// information regarding copyright ownership.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

[[reactivemessagingarchitecture]]
== Architecture

The Reactive Messaging specification defines a development model for declaring CDI _beans_ producing, consuming and processing messages. 
The communication between these components uses Reactive Streams. 

This specification relies on https://github.com/eclipse/microprofile-reactive-streams-operators[Eclipse MicroProfile Reactive Streams Operators] and http://cdi-spec.org/[CDI].

=== Concepts

This section describes the different concepts introduced by the Reactive Messaging specification

==== Overall architecture

An application using Reactive Messaging is composed by CDI beans consuming, producing and processing _messages_.
These messages can be _internal_ messages and be received/forwared from/to different brokers.

image::overall.png[Overall architecture]

Application's beans contain methods annotated with `@Incoming` and `@Outgoing` annotations. 
A method with an `@Incoming` annotation consumes messages. 
A method with an `@Outgoing` annotation produces messages, it emits messages to a destination.
A method with both an `@Incoming` and an `@Outgoing` annotation is a message processor, it consumes messages from a destination, does some transformation to them, and emits messages to destination.

==== Destination

A _destination_ is a name indicating from expected messages are consumed or to where messages are sent.
There are two type of destinations:

* Internal destination are local to the application. 
It allows implementing multi-step processing.
* Destinations can be _connected_ to remote broker or various message transport layer such as Apache Kafka or to an AMQP broker.
These destinations are managed by _connectors_.

==== Message

At the core of the Reactive Messaging specification is the concept of _message_. 
A _message_  is an enveloppe wrapping a _payload_. 
A message is sent to a specific destination and, when received and processed successfuly, _acknowledged_.

Reactive Messaging application components are addressable recipients await the arrival of messages and react to them, otherwise lying dormant. 

Message are represented by the `org.eclipse.microprofile.reactive.messaging.Message` class. 
This interface is kept minimal on purpose aiming _connectors_ to provide their own with additional metadata.
For instance, a `KafkaMessage` would provide access to the _topic_ and _partition_.

The `org.eclipse.microprofile.reactive.messaging.Message#getPayload` method retrieves the wrapped payload. 
The `org.eclipse.microprofile.reactive.messaging.Message#ack` method acknowledges the message.
Note that the `ack` method is asynchronous as acknowledgement is generally an asynchronous process.

_Plain_ messages are created using:

* `org.eclipse.microprofile.reactive.messaging.Message#of(T)` - wraps the given payload, no acknowledgement
* `org.eclipse.microprofile.reactive.messaging.Message#of(T, java.util.function.Supplier<java.util.concurrent.CompletionStage<java.lang.Void>>)` - wraps the given payload and provides the acknowlegment logic

==== Message consumption with @Incoming

The `org.eclipse.microprofile.reactive.messaging.Incoming` annotation is used on a method from a CDI bean to indicate that the method consumes messages from the specified destination:

[source,java]
----
@Incoming("my-destination")                                            // <1>
public CompletionStage<Void> consume(Message<String> message) {        // <2>
  return message.ack();
}
----
1. `my-destination` is the destination
2. the method is called for every message sent to the `my-destination` destination

Reactive Messaging support various form of method signatures.
This is detailed in the next section.

Remember that Reactive Messaging interactions are made using Reactive Streams.
A method annotated with `@Incoming` is a Reactive Streams _subscriber_ and so consumes messages according to the request it makes.
Note that the handling of the Reactive Streams protocol is managed by the Reactive Messaging implementation.

From the user perspective, whether the incoming messages come from a co-located beans or a remote message broker is transparent.
However, the user may decide to consume a specific subclass of `Message` if he is aware of this characteristic:

[source,java]
----
@Incoming("my-kafka-topic")               
public CompletionStage<Void> consume(KafkaMessage<String> message) {    // <1>
  return message.ack();
}
----
1. Explicit consumption of a `KafkaMessage`

==== Message production with @Outgoing

The `org.eclipse.microprofile.reactive.messaging.Outgoing` annotation is used on a method from a CDI bean to indicate that the method produces messages to a specified destination:

[source,java]
----
@Outgoing("my-destination")                                    // <1>
public Message<String> produce() {                             // <2>
  return Message.of("hello");                                  // <3>
}
----
1. `my-destination` is the targeted destination
2. the method is called for every consumer _request_
3. you can create a _plain_ `org.eclipse.microprofile.reactive.messaging.Message` using `org.eclipse.microprofile.reactive.messaging.Message#of(T)`

Reactive Messaging support various form of method signatures.
This is detailed in the next section.

A method annotated with `@Outgoing` is a Reactive Streams _publisher_ and so publishes messages according to the request it receives.

===== Method consuming and producing

A method can combine the `@Incoming` and `@Outgoing` annotation and acts as a Reactive Streams processor:

[source,java]
----
@Incoming("my-incoming-destination")                            // <1>
@Outgoing("my-outgoing-destination")                            // <2>
public Message<String> process(Message<String> message) { 
  return Message.of(message.getPayload().toUpperCase());
}
----
1. The incoming destination
2. The outgoing destination

==== Connectors and Messaging Provider

The application can receives and forward messages from various message broker or transport layer.
For instance, an application can be connected to a Kafka cluster, an AMQP broker or an MQTT server.


A messaging provider is an abstract concept provided by this spec, it typically will correspond to a messaging transport, such as Apache Kafka, Amazon Kinesis, RabbitMQ or Apache ActiveMQ. It is up an implementation as to which and how many transports it will support. Implementations may provide a default messaging transport, and that default may be configurable, all this is left up to the implementation to decide on the mechanism for providing that. Implementations may also provide an SPI for plugging in custom messaging providers, the definition of that SPI is up to the implementation, and beyond the scope of this specification. A future iteration of this spec may provide such an SPI, for example based on the Java EE Connector Architecture, but currently this is out of scope.

An implementation is expected to advertise and allow the differentiation between different messaging providers by providing subclasses of `MessagingProvider`. For example, a Kafka messaging provider may be provided by a class that looks like this:

[source, java]
----
public class Kafka extends MessagingProvider {
  private Kafka() { }
}
----

Note that the class is just a marker class, it provides no actual functionality. It is up to implementations to provide mappings from this class to an implementation of a messaging provider.

An application developer may specify a specific messaging provider using the `provider` property on the `@Incoming` and `@Outging` annotations.

==== Message stream operation

Message stream operation occurs according to the principles of reactive programming.
The back pressure mechanism of reactive streams means that a publisher will not send data to a subscriber unless there are outstanding subscriber requests.
This implies that data flow along the stream is enabled by the first request for data received by the publisher.
For methods that are annotated with `@Incoming` and `@Outgoing` this data flow control is handled automatically by the underlying system which will call the `@Incoming` and `@Outgoing` methods as appropriate.

Although `@Incoming` and `@Outgoing` methods remain callable from Java code, calling them directly will not affect the reactive streams they are associated with.
For example, calling an `@Outgoing` annotated method from user code will not post a message on a message queue and calling an `@Incoming` method cannot be used to read a message.
Enabling this would bypass the automatic back pressure mechanism that is one of the benefits of the specification.
The `@Incoming` and `@Outgoing` method annotations are used to declaratively define the stream which is then run by the implementation of MicroProfile Reactive Messaging without the user's code needing to handle concerns such as subscriptions or flow control within the stream.

==== Message stream shapes

The signature of message stream methods can have a number of different distinct types, offering differing levels of power and simplicity to application developers. Different shapes are supported depending on whether the method is a publisher, subscriber or processor, for example, a publishing stream supports returning MicroProfile Reactive Streams `PublisherBuilder`, but not `SubscriberBuilder`, the inverse is true for a subscribing stream.

Implementations must validate that the stream shape matches the `@Outgoing` and `@Incoming` annotations, if they don't, a CDI definition exception should be raised to the CDI container during initialization.

===== Simple method streams

The simplest shape that an application may use is a simple method. This is a method that accepts an incoming message, and possibly produces an outgoing message:

[source, java]
----
@Incoming
@Outgoing
public OutgoingMessage processMessage(IncomingMessage msg) {
  return convert(msg);
}
----

In the above example, the stream is both a publishing and subscribing stream, with a 1:1 mapping of incoming to outgoing messages. Asynchronous processing may also be used, by returning a `CompletionStage`:

[source, java]
----
@Incoming
@Outgoing
public CompletionStage<OutgoingMessage> processMessage(IncomingMessage msg) {
  return asyncConvert(msg);
}
----

Simple methods are only supported for `@Incoming` annotated methods, if there is only an `@Outgoing` annotation on the method, this is a definition error. If the method is not `@Outgoing` annotated, then the returned value is ignored - however, note that for asynchronous methods, the returned `CompletionStage` is still important for determining when message processing has completed successfully, for the purposes of message acknowledgement. When there is no `@Outgoing` annotation, `void` may also be returned.

===== Reactive streams

For more power, developers may use Reactive Streams shapes. Reactive Streams shaped methods accept no parameters, and return one of the following:

* `org.eclipse.microprofile.reactive.streams.PublisherBuilder`
* `org.eclipse.microprofile.reactive.streams.SubscriberBuilder`
* `org.eclipse.microprofile.reactive.streams.ProcessorBuilder`
* `org.reactivestreams.Publisher`
* `org.reactivestreams.Subscriber`
* `org.reactivestreams.Processor`

Implementations may optionally support other shapes, such as JDK9 Flow publishers, subscribers and processors, or other representations of Reactive Streams. Application developers are recommended to use the MicroProfile Reactive Streams builders in order to allow for the highest level of portability.

Here is a table of compatibility for processors, subscribers and publishers with `@Incoming` and `@Outgoing` annotations:

[cols="s,,", options="header"]
|======================================
|           |Incoming     |Outgoing
|Publisher  |Incompatible |Required
|Subscriber |Required     |Incompatible
|Processor  |Required     |Optional
|======================================

For example, here's a message processor:

[source, java]
----
@Incoming
@Outgoing
public PublisherBuilder<IncomingMessage, OutgoingMessage> processMessages() {
  return ReactiveStreams.<IncomingMessage>builder()
    .map(this::convert);
}
----

==== Message acknowledgement

Messages are either acknowledged explicitly, or implicitly by the implementation.

===== Explicit acknowledgement

Messages may be wrapped in a `Message`, which can be used to supply metadata, and also allows messages to be acknowledged. The contract for acknowledging messages is anything that accepts a `Message` is required to acknowledge it. So, if the application receives an incoming message wrapped in `Message`, it is responsible for invoking `Message.ack()`, and if the application produces an outgoing message wrapped in `Message`, then the spec implementation is responsible for invoking `Message.ack()`.

For example, the following application code is incorrect, since it accepts a message wrapped in `Message`, but does not acknowledge the messages:

[source, java]
----
@Incoming
public void processMessage(Message<IncomingMessage> msg) {
  System.out.println("Got message " + msg.getPayload());
}
----

Here is a correct implementation:

[source, java]
----
@Incoming
public CompletionStage<Void> processMessage(Message<IncomingMessage> msg) {
  System.out.println("Got message " + msg.getPayload());
  return msg.ack();
}
----

This implementation is also correct, since the application is returning a wrapped message back to the implementation, making it the implementations responsibility to invoke `ack()`:

[source, java]
----
@Incoming
public Message<?> processMessage(Message<IncomingMessage> msg) {
  System.out.println("Got message " + msg.getPayload());
  return msg;
}
----

The above is particularly useful for processing messages that are also being sent to a destination, as the implementation must not invoke `ack` until after the outgoing message has been sent to the destination:

[source, java]
----
@Incoming
@Outgoing
public Message<OutgoingMessage> processMessage(Message<IncomingMessage> msg) {
  return Message.of(convert(msg.getPayload()), msg::ack);
}
----

===== Implicit acknowledgement

Incoming messages may be implicitly acknowledged if the incoming message is not wrapped in `Message`. When it is acknowledged depends on the shape of the method. For simple method streams, the message should be acknowledged after the return value of the method is redeemed - for synchronous methods, this is when the method returns, for asynchronous methods, this is when the returned `CompletionStage` is redeemed.

If the method returns a subscriber, then the message should be acknowledged before being sent to the subscriber.

If the method returns a processor, then it is assumed that there is a 1:1 relationship between incoming and outgoing messages, and the implementation should acknowledge incoming messages as corresponding outgoing messages are emitted.

==== Custom message types

Implementations may provide custom subtypes of `Message` as an end user API, for the purpose of providing additional metadata associated with the messaging provider. If an application declares that it consumes or produces a subtype of the `Message` wrapper, the implementation should validate that the messaging provider supports that message wrapper type, and raise a deployment exception if it doesn't.
