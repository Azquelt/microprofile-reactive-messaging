//
// Copyright (c) 2018-2019 Contributors to the Eclipse Foundation
//
// See the NOTICE file(s) distributed with this work for additional
// information regarding copyright ownership.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

[[reactivemessagingarchitecture]]
== Architecture

The Reactive Messaging specification defines a development model for declaring CDI _beans_ producing, consuming and processing messages. 
The communication between these components uses Reactive Streams. 

This specification relies on https://github.com/eclipse/microprofile-reactive-streams-operators[Eclipse MicroProfile Reactive Streams Operators] and http://cdi-spec.org/[CDI].

=== Concepts

This section describes the different concepts introduced by the Reactive Messaging specification

==== Overall architecture

An application using Reactive Messaging is composed of CDI beans consuming, producing and processing _messages_.

These messages can be wholly _internal_ to the application or can be sent and received via different message brokers.

image::overall.png[Overall architecture]

Application's beans contain methods annotated with `@Incoming` and `@Outgoing` annotations. 
A method with an `@Incoming` annotation consumes messages from a _channel_. 
A method with an `@Outgoing` annotation publishes messages to a _channel_.
A method with both an `@Incoming` and an `@Outgoing` annotation is a message processor, it consumes messages from a _channel_, does some transformation to them, and publishes messages to another_channel_.

==== Channel

A _channel_ is a name indicating which source or destination of messages is used.
Channels are opaque `Strings`.

There are two types of channel:

* Internal channels are local to the application. 
They allows implementing multi-step processing where several _beans_ from the same application form a chain of processing.
* Channels can be _connected_ to remote brokers or various message transport layers such as Apache Kafka or to an AMQP broker.
These channels are managed by _connectors_.

==== Message

At the core of the Reactive Messaging specification is the concept of _message_. 
A _message_  is an enveloppe wrapping a _payload_. 
A message is sent to a specific channel and, when received and processed successfuly, _acknowledged_.

Reactive Messaging application components are addressable recipients which await the arrival of messages on a channel and react to them, otherwise lying dormant. 

Messages are represented by the `org.eclipse.microprofile.reactive.messaging.Message` class. 
This interface is intentionally kept minimal. The aim is that _connectors_ will provide their own implementations with additional metadata that is relevant to that connector.
For instance, a `KafkaMessage` would provide access to the _topic_ and _partition_.

The `org.eclipse.microprofile.reactive.messaging.Message#getPayload` method retrieves the wrapped payload. 
The `org.eclipse.microprofile.reactive.messaging.Message#ack` method acknowledges the message.
Note that the `ack` method is asynchronous as acknowledgement is generally an asynchronous process.

_Plain_ messages are created using:

* `org.eclipse.microprofile.reactive.messaging.Message#of(T)` - wraps the given payload, no acknowledgement
* `org.eclipse.microprofile.reactive.messaging.Message#of(T, java.util.function.Supplier<java.util.concurrent.CompletionStage<java.lang.Void>>)` - wraps the given payload and provides the acknowlegment logic

==== Message consumption with @Incoming

The `org.eclipse.microprofile.reactive.messaging.Incoming` annotation is used on a method from a CDI bean to indicate that the method consumes messages from the specified channel:

[source,java]
----
@Incoming("my-channel")                                                // <1>
public CompletionStage<Void> consume(Message<String> message) {        // <2>
  return message.ack();
}
----
1. `my-channel` is the channel
2. the method is called for every message sent to the `my-channel` channel

Reactive Messaging supports various forms of method signatures.
This is detailed in the next section.

Remember that Reactive Messaging interactions are assembled from Reactive Streams.
A method annotated with `@Incoming` is a Reactive Streams _subscriber_ and so consumes messages that fit with the message signature and its annotations.
Note that the handling of the Reactive Streams protocol, such as subscriptions and back pressure, is managed by the Reactive Messaging implementation.

From the user perspective, whether the incoming messages come from co-located beans or a remote message broker is transparent.
However, the user may decide to consume a specific subclass of `Message` if the user is aware of this characteristic:

[source,java]
----
@Incoming("my-kafka-topic")               
public CompletionStage<Void> consume(KafkaMessage<String> message) {    // <1>
  return message.ack();
}
----
1. Explicit consumption of a `KafkaMessage`

==== Message production with @Outgoing

The `org.eclipse.microprofile.reactive.messaging.Outgoing` annotation is used to annotate a method from a CDI bean to indicate that the method publishes messages to a specified channel:

[source,java]
----
@Outgoing("my-channel")                                        // <1>
public Message<String> publish() {                             // <2>
  return Message.of("hello");                                  // <3>
}
----
1. `my-channel` is the targeted channel
2. the method is called for every consumer _request_
3. you can create a _plain_ `org.eclipse.microprofile.reactive.messaging.Message` using `org.eclipse.microprofile.reactive.messaging.Message#of(T)`

Reactive Messaging supports various forms of method signatures.
This is detailed in the next section.

A method annotated with `@Outgoing` is a Reactive Streams _publisher_ and so publishes messages according to the requests it receives.

===== Method consuming and producing

A method can combine the `@Incoming` and `@Outgoing` annotation and will then act as a Reactive Streams processor:

[source,java]
----
@Incoming("my-incoming-channel")                            // <1>
@Outgoing("my-outgoing-channel")                            // <2>
public Message<String> process(Message<String> message) { 
  return Message.of(message.getPayload().toUpperCase());
}
----
1. The incoming channel
2. The outgoing channel

==== Connectors and Messaging Providers

The application can receive and forward messages from various message brokers or transport layers.
For instance, an application can be connected to a Kafka cluster, an AMQP broker or an MQTT server.

Reactive Messaging _Connectors_ are extensions managing the communication with a specific transport technology.
They are responsible for mapping a specific _channel_ to remote sink or source of messages.
This mapping is configured in the application configuration.
Note that an implementation may provide various ways to configure the mapping, but support for MicroProfile Config as a configuration source is mandatory.

Connectors are associated with a `org.eclipse.microprofile.reactive.messaging.MessagingProvider` class corresponding to a messaging transport, such as Apache Kafka, Amazon Kinesis, RabbitMQ or Apache ActiveMQ.
For instance, an hypthetic Kafka connector would be associated with the following class:

[source, java]
----
public class Kafka extends MessagingProvider {
  private Kafka() { }
}
----

Note that the class is just a marker class, it provides no actual functionality. 
The user can associate a channel with this connector using:

[source, properties]
----
mp.messaging.incoming.my-kafka-topic.type=...Kafka  # <1>
----
1. the value is the fully qualified name of the `MessagingProvider` class associated with the connector.

The configuration format is detailed later in this document.

The Reactive Messaging implementation is responsible for finding the connector implementation associated with the given `MessagingProvider` in the user configuration.
If the connector cannot be found, the deployment of the application must be failed.

The Reactive Messaging specification provides a SPI to implement connectors.

=== Design

==== Message stream operation

Message stream operation occurs according to the principles of reactive programming.
The back pressure mechanism of reactive streams means that a publisher will not send data to a subscriber unless there are outstanding subscriber requests.
This implies that data flow along the stream is enabled by the first request for data received by the publisher.
For methods that are annotated with `@Incoming` and `@Outgoing` this data flow control is handled automatically by the underlying system which will call the `@Incoming` and `@Outgoing` methods as appropriate.

Although `@Incoming` and `@Outgoing` methods remain callable from Java code, calling them directly will not affect the reactive streams they are associated with.
For example, calling an `@Outgoing` annotated method from user code will not post a message on a message queue and calling an `@Incoming` method cannot be used to read a message.
Enabling this would bypass the automatic back pressure mechanism that is one of the benefits of the specification.
The `@Incoming` and `@Outgoing` method annotations are used to declaratively define the stream which is then run by the implementation of MicroProfile Reactive Messaging without the user's code needing to handle concerns such as subscriptions or flow control within the stream.

==== Supported Bean scope


==== Method signatures

This section lists the method signatures that implementation must support.


The signature of message stream methods can have a number of different distinct types, offering differing levels of power and simplicity to application developers. Different shapes are supported depending on whether the method is a publisher, subscriber or processor, for example, a publishing stream supports returning MicroProfile Reactive Streams `PublisherBuilder`, but not `SubscriberBuilder`, the inverse is true for a subscribing stream.

Implementations must validate that the stream shape matches the `@Outgoing` and `@Incoming` annotations, if they don't, a CDI definition exception should be raised to the CDI container during initialization.

===== Simple method streams

The simplest shape that an application may use is a simple method. This is a method that accepts an incoming message, and possibly publishes an outgoing message:

[source, java]
----
@Incoming
@Outgoing
public OutgoingMessage processMessage(IncomingMessage msg) {
  return convert(msg);
}
----

In the above example, the stream is both a publishing and subscribing stream, with a 1:1 mapping of incoming to outgoing messages. Asynchronous processing may also be used, by returning a `CompletionStage`:

[source, java]
----
@Incoming
@Outgoing
public CompletionStage<OutgoingMessage> processMessage(IncomingMessage msg) {
  return asyncConvert(msg);
}
----

Simple methods are only supported for `@Incoming` annotated methods, if there is only an `@Outgoing` annotation on the method, this is a definition error. If the method is not `@Outgoing` annotated, then the returned value is ignored - however, note that for asynchronous methods, the returned `CompletionStage` is still important for determining when message processing has completed successfully, for the purposes of message acknowledgement. When there is no `@Outgoing` annotation, `void` may also be returned.

===== Reactive streams

For more power, developers may use Reactive Streams shapes. Reactive Streams shaped methods accept no parameters, and return one of the following:

* `org.eclipse.microprofile.reactive.streams.PublisherBuilder`
* `org.eclipse.microprofile.reactive.streams.SubscriberBuilder`
* `org.eclipse.microprofile.reactive.streams.ProcessorBuilder`
* `org.reactivestreams.Publisher`
* `org.reactivestreams.Subscriber`
* `org.reactivestreams.Processor`

Implementations may optionally support other shapes, such as JDK9 Flow publishers, subscribers and processors, or other representations of Reactive Streams. Application developers are recommended to use the MicroProfile Reactive Streams builders in order to allow for the highest level of portability.

Here is a table of compatibility for processors, subscribers and publishers with `@Incoming` and `@Outgoing` annotations:

[cols="s,,", options="header"]
|======================================
|           |Incoming     |Outgoing
|Publisher  |Incompatible |Required
|Subscriber |Required     |Incompatible
|Processor  |Required     |Optional
|======================================

For example, here's a message processor:

[source, java]
----
@Incoming
@Outgoing
public PublisherBuilder<IncomingMessage, OutgoingMessage> processMessages() {
  return ReactiveStreams.<IncomingMessage>builder()
    .map(this::convert);
}
----

==== Message acknowledgement

Messages are either acknowledged explicitly, or implicitly by the implementation.

===== Explicit acknowledgement

Messages may be wrapped in a `Message`, which can be used to supply metadata, and also allows messages to be acknowledged. The contract for acknowledging messages is anything that accepts a `Message` is required to acknowledge it. So, if the application receives an incoming message wrapped in `Message`, it is responsible for invoking `Message.ack()`, and if the application publish an outgoing message wrapped in `Message`, then the spec implementation is responsible for invoking `Message.ack()`.

For example, the following application code is incorrect, since it accepts a message wrapped in `Message`, but does not acknowledge the messages:

[source, java]
----
@Incoming
public void processMessage(Message<IncomingMessage> msg) {
  System.out.println("Got message " + msg.getPayload());
}
----

Here is a correct implementation:

[source, java]
----
@Incoming
public CompletionStage<Void> processMessage(Message<IncomingMessage> msg) {
  System.out.println("Got message " + msg.getPayload());
  return msg.ack();
}
----

This implementation is also correct, since the application is returning a wrapped message back to the implementation, making it the implementations responsibility to invoke `ack()`:

[source, java]
----
@Incoming
public Message<?> processMessage(Message<IncomingMessage> msg) {
  System.out.println("Got message " + msg.getPayload());
  return msg;
}
----

The above is particularly useful for processing messages that are also being sent to a destination, as the implementation must not invoke `ack` until after the outgoing message has been sent to the destination:

[source, java]
----
@Incoming
@Outgoing
public Message<OutgoingMessage> processMessage(Message<IncomingMessage> msg) {
  return Message.of(convert(msg.getPayload()), msg::ack);
}
----

===== Implicit acknowledgement

Incoming messages may be implicitly acknowledged if the incoming message is not wrapped in `Message`. When it is acknowledged depends on the shape of the method. For simple method streams, the message should be acknowledged after the return value of the method is redeemed - for synchronous methods, this is when the method returns, for asynchronous methods, this is when the returned `CompletionStage` is redeemed.

If the method returns a subscriber, then the message should be acknowledged before being sent to the subscriber.

If the method returns a processor, then it is assumed that there is a 1:1 relationship between incoming and outgoing messages, and the implementation should acknowledge incoming messages as corresponding outgoing messages are published.

==== Custom message types

Implementations may provide custom subtypes of `Message` as an end user API, for the purpose of providing additional metadata associated with the messaging provider. If an application declares that it consumes or produces a subtype of the `Message` wrapper, the implementation should validate that the messaging provider supports that message wrapper type, and raise a deployment exception if it doesn't.
